# 性能优化案例 - 分布式架构与微服务

> **导航**：[🔙 返回目录页](./README.md)
---
### 案例一：高并发场景下 Redis 分布式锁的安全性优化

####   科普的简介

> 我对**商品库存扣减**场景下，做了**分布式锁可靠性**的优化。主要是针对**业务执行超时导致锁自动释放**的问题，引入了**看门狗 (Watchdog) 自动续期机制**配合 Lua 脚本原子性操作。最终达到的效果是**彻底解决了因网络抖动引发的超卖问题，并将误删锁的概率降为 0**。

#### 背景

在秒杀大促活动中，库存服务 QPS 峰值达到 3000+。原有的方案是使用 Redis 的 `SETNX` 设置固定的 5 秒过期时间。监控发现，当出现 Full GC 卡顿或网络波动时，业务逻辑耗时超过 5 秒，锁会被 Redis 自动清除，导致第二个线程并发进入扣减库存，引发数据不一致（超卖）。

#### 实现逻辑

1. **原子解锁：** 放弃代码层面的“查后删”，封装 Lua 脚本实现 `if redis.call("get", KEYS[1]) == ARGV[1] then return redis.call("del", KEYS[1]) else return 0 end`，保证“验证身份+删除锁”的原子性。
2. **看门狗机制 (Watchdog)：**
* 加锁时不设置硬性的业务过期时间，而是设置一个初始 TTL（如 10s）。
* 启动一个后台 Goroutine（守护协程）。
* 协程每隔 `TTL/3`（约 3s）检查一次，如果锁还被当前进程持有，则通过 `PEXPIRE` 命令重置 TTL 为 10s。


3. **自旋重试：** 在获取锁失败时，不直接返回错误，而是采用“指数退避”策略进行轻量级自旋重试。

#### 难点

1. **死锁兜底：** 必须确保如果服务进程被 `kill -9` 强杀，后台续期协程也会随之挂掉，Redis 端的 Key 最终会自然过期，防止造成永久死锁。
2. **续期风暴：** 在极高并发下，大量的续期操作本质上也是写操作，需要调整合理的检测间隔（Check Interval），避免给 Redis 主节点造成过大压力。

#### 结果

1. **业务稳定性：** 库存超卖事故率从偶发降为 **0%**。
2. **吞吐量：** 系统稳定承载 3000+ QPS，且消除了因锁失效导致的数据回滚修复成本。

#### 思考

1. **架构权衡 (AP vs CP)：** 我考虑过使用 Redlock 解决 Redis 主节点挂掉丢锁的问题，但 Redlock 运维成本高且有争议。在库存场景下，性能（AP）优先，极小概率的主从切换丢锁可以通过业务层的“库存流水对账”来兜底。
2. **扩展性：** 如果未来 QPS 进一步升高，我会考虑**分段锁**（类似 ConcurrentHashMap），将库存 100 拆成 `stock_0_20`, `stock_20_40` 等，减少锁竞争。
