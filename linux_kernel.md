# 性能优化案例 - Linux 内核

> **导航**：[🔙 返回目录页](./README.md)
---
### 案例一：基于 AF_PACKET V3 的零拷贝抓包优化

#### 跟面试官科普的简介

> 面试官，针对 10Gbps+ 高吞吐流量采集场景，我实施了**基于 Linux AF_PACKET V3 的零拷贝（Zero-Copy）方案**。主要是利用 **Ring Buffer 机制配合 mmap 内存映射**，消除了内核态到用户态的数据拷贝开销，最终使单核 CPU 占用降低了 40%，并解决了高并发下的丢包问题。

#### 背景

在高频抓包场景下，传统的 `socket(recv)` 方式每收到一个包都会触发一次系统调用和一次内存拷贝（Kernel to User）。在流量达到百万 PPS（包/秒）级别时，CPU 大量时间消耗在 `copy_to_user` 和上下文切换上，导致处理瓶颈。

#### 实现逻辑

1. **协议升级**：弃用旧版 Socket，初始化 Socket 时启用 `TPACKET_V3` 选项（支持 Block 级批量读写）。
2. **内存映射**：通过 `mmap` 将内核的接收环形缓冲区（RX Ring Buffer）映射到用户进程空间，建立共享内存区。
3. **直接读取**：用户态程序直接通过指针访问映射区的 Frame 数据，完全跳过 `memcpy`。
4. **BPF 前置过滤**：在 Socket 层加载 BPF 代码，仅让业务关注的协议包进入 Ring Buffer，源头降噪。

#### 难点

1. **状态位同步**：内核与用户态通过共享内存中的状态位（Status Bit）协作。需精确处理所有权的原子流转，避免竞态条件导致的数据错乱。
2. **块轮询策略**：V3 版本是基于 Block 的，需要平衡“及时响应”与“批处理效率”，设计合理的超时与轮询机制，避免忙等待空耗 CPU。

#### 结果

1. 小包转发场景下，系统调用次数减少 90% 以上。
2. 整体 CPU 开销降低约 40%，极限吞吐量提升 2 倍以上。

#### 思考

1. **方案权衡**：面试官可能会问为什么不用 DPDK？回答：DPDK 需要独占网卡和 CPU，侵入性太强，适合网关不适合 Agent。AF_PACKET V3 是兼顾性能与资源共存的最佳方案。

---
### 案例二：基于 RCU 思想的配置无损热更新

#### 跟面试官科普的简介

> 面试官，针对配置更新会阻塞高频数据采集流水线的问题，我采用了**基于 RCU（Read-Copy-Update）思想的无锁热更新方案**。主要是利用**原子指针交换（Atomic Swap）和快照读**，实现了读写分离。最终效果是配置下发瞬间，数据面吞吐量**零抖动**。

#### 背景

采集器的策略（黑白名单、采样率）需要动态更新。这是一个典型的“写少读多”场景。如果用读写锁（RwLock），写锁进入时会强制阻塞所有读线程，导致数据流瞬间断流（Stop-the-world）。

#### 实现逻辑

1. **原子指针**：全局配置存储在 `ArcSwap<Config>` (基于 AtomicPtr) 中。
2. **快照读取**：工作线程处理每个 Batch 前，原子地加载当前配置的“快照”（引用计数+1）。该操作是 Wait-free 的，耗时极微。
3. **后台构建**：更新发生时，在后台线程构建全新的 Config 对象结构。
4. **原子替换**：构建完成后，通过 CPU 原子指令替换全局指针。旧配置在所有读线程释放引用后自动回收。

#### 难点

1. **内存序 (Memory Ordering)**：需正确使用 `SeqCst` 或 `Acquire/Release` 屏障，确保新配置发布的可见性。
2. **延迟释放**：必须保证旧配置只有在完全没人使用时才物理销毁，否则会崩溃（Rust 的 Arc 智能指针天然解决了此问题）。

#### 结果

1. 配置变更期间，PPS（包处理率）曲线完全平滑，无任何下凹。
2. 彻底解决了因管控面操作影响数据面性能的隐患。

#### 思考

1. **适用边界**：RCU 仅适用于读多写少的场景。如果配置每秒变几十次，频繁分配新内存的开销会反而大于锁，需要根据业务场景定夺。
