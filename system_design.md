# 性能优化案例 - 系统设计

> **导航**：[🔙 返回目录页](./README.md)
---
### 案例一：任务调度系统的强一致性锁迁移 (Redis -> Etcd)

#### 跟面试官科普的简介

> 面试官，我对**核心任务调度系统**场景下，做了**锁的一致性升级**优化。主要是针对**Redis 异步复制可能导致锁丢失**的问题，将锁组件迁移到了**Etcd**，利用其 **Raft 共识算法和 Watch 机制**。最终达到的效果是**实现了 100% 的任务互斥执行（强一致性），同时将应用层 CPU 负载降低了 15%**。

#### 背景

金融对账任务要求绝对的 Singleton（单例）执行。原方案使用 Redis 锁，存在两个痛点：

1. **数据脏写：** Redis 主从发生故障转移时，锁数据可能丢失，导致两个 Worker 节点同时拿到锁执行任务。
2. **CPU 浪费：** 抢锁失败的节点在一个 `for` 循环里不断 Sleep 和重试（Spin Lock），导致空闲节点 CPU 使用率虚高。

#### 实现逻辑

1. **架构迁移：** 引入 Etcd (`clientv3/concurrency`)，利用 Raft 协议保证只有集群过半节点同意才算加锁成功。
2. **租约保活 (Lease)：** 创建 Session 并绑定 Lease，开启 KeepAlive 自动续租。进程崩溃会导致 Session 断开，Lease 过期，锁自动释放。
3. **Watch 替代轮询：**
* 节点在 Etcd 创建临时顺序节点。
* 判断自己是否是序号最小的。
* 如果不是，**Watch（监听）**前一个序号节点的删除事件，挂起当前协程，实现“被动唤醒”。



#### 难点

1. **Session 脑裂处理：** 网络闪断可能导致 Etcd 服务端认为 Lease 过期而删锁，但客户端还以为自己持有锁。我们在代码里监听了 `Session.Done()` channel，一旦收到信号，立即停止手头业务，防止脑裂。

#### 结果

1. **可靠性：** 任务重复执行事故彻底归零，即使在 Etcd Leader 切换期间也能保证一致性。
2. **资源优化：** 等待节点的 CPU 使用率从 15% 降至 **<1%**（得益于消除了忙等待）。

#### 思考

1. **选型哲学：** 这体现了 **Correctness over Performance**（正确性高于性能）。Redis 快但不稳，Etcd 稳但慢。在低频（QPS < 100）但高价值的任务调度场景，Etcd 是唯一正解。
2. **兜底方案：** 如果没有 Etcd 环境，也可以利用 MySQL 的唯一索引 (`INSERT IGNORE`) 做兜底，但 DB 轮询压力大，不如 Etcd 的 Watch 优雅。
